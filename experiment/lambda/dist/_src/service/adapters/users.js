// Auto-generated by Invoker Generator
// Lambda Handler for UsersHandler
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { UsersHandler } from "../handlers/users";
import { Request } from "../handlers/_";
import { LambdaCapabilityFactory } from "@frogfish/swaggen-lambda"; // Import Lambda capability factory
let capabilitiesInstance = null;
let handlerInstance = null;
// Function to initialize capabilities
function initializeCapabilities() {
    return __awaiter(this, void 0, void 0, function* () {
        if (!capabilitiesInstance) {
            capabilitiesInstance = (() => __awaiter(this, void 0, void 0, function* () {
                // Get capabilities from the environment variable and parse it as a JSON array
                const capabilitiesEnv = process.env.CAPABILITIES || '[]';
                let capabilitiesArray;
                try {
                    capabilitiesArray = JSON.parse(capabilitiesEnv);
                    if (!Array.isArray(capabilitiesArray)) {
                        throw new Error('CAPABILITIES environment variable must be a JSON array');
                    }
                }
                catch (error) {
                    console.error("Error parsing CAPABILITIES environment variable:", error);
                    capabilitiesArray = []; // Default to an empty array if parsing fails
                }
                // Initialize capabilities using the parsed array
                const awsFactory = new LambdaCapabilityFactory();
                return awsFactory.create(capabilitiesArray);
            }))();
        }
        return capabilitiesInstance;
    });
}
// Function to initialize the handler
function initializeHandler() {
    if (!handlerInstance) {
        handlerInstance = (() => __awaiter(this, void 0, void 0, function* () {
            const capabilities = yield initializeCapabilities();
            return new UsersHandler(capabilities);
        }))();
    }
    return handlerInstance;
}
// List of supported HTTP methods for this endpoint
const supportedMethods = [
    'get',
    'post'
];
// AWS Lambda handler function for the endpoint
export function handler(event, context) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const handler = yield initializeHandler();
            // Extract HTTP method and normalize it to lowercase
            const methodName = event.httpMethod.toLowerCase();
            // Check if the method is supported
            if (!supportedMethods.includes(methodName)) {
                return {
                    statusCode: 405,
                    body: JSON.stringify({ error: 'Method Not Allowed' }),
                };
            }
            // Create an instance of your custom Request class
            const internalReq = new Request(event.httpMethod, event.headers, event.body ? JSON.parse(event.body) : undefined, event.path);
            // Invoke the corresponding method on the handler instance
            // @ts-ignore indexing suppression as the workaround is not pragmatic
            const handlerResponse = yield handler[methodName](internalReq);
            // Return the response in AWS Lambda format
            return {
                statusCode: handlerResponse.statusCode,
                headers: handlerResponse.headers,
                body: JSON.stringify(handlerResponse.body),
            };
        }
        catch (error) {
            console.error(error);
            return {
                statusCode: 500,
                body: JSON.stringify({ error: 'Internal Server Error' }),
            };
        }
    });
}
