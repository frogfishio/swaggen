
// Auto-generated by Invoker Generator
// This file contains the Request, Response, and BaseHandler classes.

import { Capabilities, LoggingCapability } from "@frogfish/swaggen-types"; // Import capabilities and logger types


export class Request {
  method: string;
  headers: Record<string, string>;
  body: any;
  url: string;

  private urlInstance: URL;

  constructor(
    method: string,
    headers: Record<string, string> = {},
    body: any = null,
    url: string = ""
  ) {
    this.method = method.toUpperCase(); // Ensure HTTP method is uppercase
    this.headers = this.normalizeHeaders(headers);
    this.body = body;
    this.url = url;
    this.urlInstance = new URL(url);
  }

  // Utility to get query parameters
  getQueryParam(name: string): string | null {
    return this.urlInstance.searchParams.get(name);
  }

  // Utility to get all query parameters as an object
  getAllQueryParams(): Record<string, string> {
    return Object.fromEntries(this.urlInstance.searchParams.entries());
  }

  // Utility to get a header value (case-insensitive)
  getHeader(name: string): string | null {
    return this.headers[name.toLowerCase()] || null;
  }

  // Utility to normalize headers (case-insensitive storage)
  private normalizeHeaders(headers: Record<string, string>): Record<string, string> {
    const normalizedHeaders: Record<string, string> = {};
    for (const [key, value] of Object.entries(headers)) {
      normalizedHeaders[key.toLowerCase()] = value;
    }
    return normalizedHeaders;
  }

  // Utility to safely parse JSON body
  parseJsonBody<T = any>(): T | null {
    if (typeof this.body === "string") {
      try {
        return JSON.parse(this.body);
      } catch (error) {
        console.warn("Failed to parse JSON body:", error);
        return null;
      }
    }
    return this.body as T;
  }

  // Get path name from URL
  get path(): string {
    return this.urlInstance.pathname;
  }
}


export class Response<T = any> {
  statusCode: number;
  headers: Record<string, string>;
  body: T;

  constructor(
    statusCode: number = 200,
    headers: Record<string, string> = {},
    body: T = null as any
  ) {
    this.statusCode = statusCode;
    this.headers = this.normalizeHeaders(headers);
    this.body = body;
  }

  // Set status code
  setStatus(code: number): this {
    this.statusCode = code;
    return this;
  }

  // Add or update a header
  setHeader(name: string, value: string): this {
    this.headers[name.toLowerCase()] = value;
    return this;
  }

  // Convenience method to set multiple headers
  setHeaders(headers: Record<string, string>): this {
    for (const [key, value] of Object.entries(headers)) {
      this.setHeader(key, value);
    }
    return this;
  }

  // Send a JSON response
  sendJson(body: T): this {
    this.setHeader("Content-Type", "application/json");
    this.body = body;
    return this;
  }

  // Normalize headers (case-insensitive)
  private normalizeHeaders(headers: Record<string, string>): Record<string, string> {
    const normalizedHeaders: Record<string, string> = {};
    for (const [key, value] of Object.entries(headers)) {
      normalizedHeaders[key.toLowerCase()] = value;
    }
    return normalizedHeaders;
  }
}


interface Handler {
  get?(req: Request): Promise<Response>;
  post?(req: Request): Promise<Response>;
  put?(req: Request): Promise<Response>;
  delete?(req: Request): Promise<Response>;
}

export class BaseHandler implements Handler {
  protected capabilities?: Capabilities;
  protected logger: LoggingCapability | null = null;

  constructor(capabilities?: Capabilities) {
    this.capabilities = capabilities;

    if (capabilities && capabilities.logging) {
      this.logger = capabilities.logging;
    }
  }

  // Handle GET request
  public async get(req: Request): Promise<Response> {
    this.logger?.info("GET request received");
    return this.methodNotImplemented("GET");
  }

  // Handle POST request
  public async post(req: Request): Promise<Response> {
    this.logger?.info("POST request received");
    return this.methodNotImplemented("POST");
  }

  // Handle PUT request
  public async put(req: Request): Promise<Response> {
    this.logger?.info("PUT request received");
    return this.methodNotImplemented("PUT");
  }

  // Handle DELETE request
  public async delete(req: Request): Promise<Response> {
    this.logger?.info("DELETE request received");
    return this.methodNotImplemented("DELETE");
  }

  // Handle PATCH request
  public async patch(req: Request): Promise<Response> {
    this.logger?.info("PATCH request received");
    return this.methodNotImplemented("PATCH");
  }

  // Handle HEAD request
  public async head(req: Request): Promise<Response> {
    this.logger?.info("HEAD request received");
    return this.methodNotImplemented("HEAD");
  }

  // Handle OPTIONS request
  public async options(req: Request): Promise<Response> {
    this.logger?.info("OPTIONS request received");
    return this.methodNotImplemented("OPTIONS");
  }

  // Utility to return a 501 Not Implemented response
  protected methodNotImplemented(method: string): Response {
    this.logger?.warn(`${method} method not implemented`);
    return new Response(501, { "Content-Type": "application/json" }, { error: `${method} method not implemented` });
  }

  // Utility to return a 400 Bad Request response
  protected badRequest(message: string = "Bad Request"): Response {
    this.logger?.warn(`Bad Request: ${message}`);
    return new Response(400, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 401 Unauthorized response
  protected unauthorized(message: string = "Unauthorized"): Response {
    this.logger?.warn(`Unauthorized: ${message}`);
    return new Response(401, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 403 Forbidden response
  protected forbidden(message: string = "Forbidden"): Response {
    this.logger?.warn(`Forbidden: ${message}`);
    return new Response(403, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 404 Not Found response
  protected notFound(message: string = "Not Found"): Response {
    this.logger?.warn(`Not Found: ${message}`);
    return new Response(404, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 409 Conflict response
  protected conflict(message: string = "Conflict"): Response {
    this.logger?.warn(`Conflict: ${message}`);
    return new Response(409, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 422 Unprocessable Entity response
  protected unprocessableEntity(message: string = "Unprocessable Entity"): Response {
    this.logger?.warn(`Unprocessable Entity: ${message}`);
    return new Response(422, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 500 Internal Server Error response
  protected internalServerError(message: string = "Internal Server Error"): Response {
    this.logger?.error(`Internal Server Error: ${message}`);
    return new Response(500, { "Content-Type": "application/json" }, { error: message });
  }

  // Utility to return a 503 Service Unavailable response
  protected serviceUnavailable(message: string = "Service Unavailable"): Response {
    this.logger?.warn(`Service Unavailable: ${message}`);
    return new Response(503, { "Content-Type": "application/json" }, { error: message });
  }
}